-- GET CURRENT LOGGED IN USER'S USERNAME 
SELECT CURRENT_USER ; 

-- CREATE FUNCTION TO CHECK IF LOGGED IN USER IS IN ADMIN ROLE GROUP 
CREATE OR REPLACE FUNCTION RESTRICT_UPDATE_DELETE_TO_TABLE()
RETURNS TRIGGER AS $$
BEGIN
    IF UPPER(CURRENT_USER) NOT IN (
        SELECT UPPER(U.USENAME) AS USERNAME
        FROM pg_user AS U 
        JOIN pg_group AS G 
        ON U.usesysid = ANY(G.grolist) 
        WHERE UPPER(G.groname) = 'ADMIN_ROLE' 
    )
    -- IF USER NOT IN RETURNED LIST, RAISE EXCEPTION WHICH BLOCKS FLOW/SEQUENCE OF SQL ACTIONS EXECUTED
    THEN RAISE EXCEPTION 'You do not have the ADMIN ROLE privileges required to perform this action';
    END IF;
    -- DETERMINE TO RETURN NEW OR OLD 
    IF UPPER(TG_OP) IN ('INSERT', 'UPDATE') THEN RETURN NEW;
    ELSEIF UPPER(TG_OP) IN ('DELETE') THEN RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;
-- THIS FUNCTION CAN NOW BE CALLED IN MULTIPLE TRIGGERS IF REQUIRED 

-- ========================================================================================================
-- ========================================================================================================

-- CREATE AUDIT TABLE 
CREATE EXTENSION IF NOT EXISTS "uuid-ossp"; -- ENABLES EXTENSION FOR uuid GENERATION

CREATE TABLE DEV_HISTORY.RULESREPO_AUDIT
(
    AUDIT_ID UUID NOT NULL PRIMARY KEY,
    USER_ID VARCHAR(50) NOT NULL DEFAULT UPPER(CURRENT_USER),
    USER_ACTION VARCHAR(50) NOT NULL,
    AUDIT_DATETIME TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- CONSTRAINT FOR NO FUTURE AUDIT DATE 
ALTER TABLE DEV_HISTORY.RULES_REPO ADD 
CONSTRAINT AUDIT_DATE_CHECK CHECK (AUDIT_DATETIME <= CURRENT_TIMESTAMP);
-- CONSTRAINT TO RESTRICT VALUES IN USER ACTION COLUMN 
ALTER TABLE DEV_HISTORY.RULES_REPO ADD 
CONSTRAINT ACTION_VALUE_CHECK (USER_ACTION IN ('INSERT', 'UPDATE', 'DELETE'));

-- CREATE FUNCTION TO GENERATE UUID VALUE AT TABLE INSERT 
CREATE OR REPLACE FUNCTION GENERATE_UUID_TRIGGER()
RETURNS TRIGGER AS $$
BEGIN
    NEW.AUDIT_ID := PUBLIC.uuid_generate_V4() ; -- GENERATE UUID VALUE AND ASSIGN TO AUDIT_ID COLUMN 
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
-- CREATE TRIGGER TO EXECUTE ABOVE FUNCTION ON TABLE 
CREATE TRIGGER UUID_GENERATION_TRIGGER
BEFORE INSERT ON DEV_HISTORY.RULESREPO_AUDIT 
FOR EACH ROW EXECUTE FUNCTION GENERATE_UUID_TRIGGER();

-- IMPLEMENT TRIGGER TO EXECUTE FUNCTION RESTRICT_UPDATE_DELETE_TO_TABLE()
-- THIS IS TO ENSURE ONLY AN ADMIN CAN GO INTO AUDIT TABLE AND MODIFY/DELETE A ROW 
CREATE TRIGGER APPLY_RESTRICT_FUNC_AUDIT
BEFORE UPDATE OR DELETE ON DEV_HISTORY.RULESREPO_AUDIT
FOR EACH ROW EXECUTE FUNCTION RESTRICT_UPDATE_DELETE_TO_TABLE() ;

-- EXAMPLE OF SETTING DEFAULT HIGH END TIME UPON ENTRY : NO LONGER REQUIRED
--END_DATETIME TIMESTAMP NOT NULL DEFAULT '9999-12-31 00:00:00.000000'

-- ========================================================================================================
-- ========================================================================================================

-- CREATE RULESET MASTER TABLE 
CREATE TABLE DEV.DQ_CTL_RULESET 
(
    RULESET_ID BIGINT NOT NULL PRIMARY KEY,
    RULESET_TYPE VARCHAR(15) NOT NULL,
    RULESET_DESC TEXT NOT NULL, 
    RULESET_OWNER VARCHAR(50) NOT NULL DEFAULT UPPER(CURRENT_USER),
    RULESET_DISABLED CHAR(1) NOT NULL DEFAULT 'N'
);

-- ADD CONSTRAINT TO ENSURE DISABLED VALUE ONLY `Y` OR `N`
ALTER TABLE DEV.DQ_CTL_RULESET ADD CONSTRAINT RULESET_DISABLE CHECK (RULESET_DISABLED IN ('Y','N'));
-- CONSTRAINT FOR VALUES IN RULESET TYPE 
ALTER TABLE DEV.DQ_CTL_RULESET ADD CONSTRAINT RULESET_TYPE_VAL
CHECK (RULESET_TYPE IN ('ANALYTICAL', 'STATISTICAL'));
-- CONSTRAINT TO RESTRICT EMPTY (NON-NULL TEXT FIELDS)
ALTER TABLE DEV.DQ_CTL_RULESET ADD CONSTRAINT RULESET_DESC_POPULATED
CHECK (TRIM(RULESET_DESC) != '');
ALTER TABLE DEV.DQ_CTL_RULESET ADD CONSTRAINT RULESET_OWNER_POPULATED
CHECK (TRIM(RULESET_OWNER) != '');
-- CONSTRAINT THAT RULESET_DESC IS UNIQUE 
ALTER TABLE DEV.DQ_CTL_RULESET ADD CONSTRAINT RULESET_DESC_UNQ UNIQUE (RULESET_DESC) ;


-- CREATE A FUNCTION THAT GENERATES A RULESET_ID IF ONE NOT PROVIDED AT INTIAL INSERT
CREATE OR REPLACE FUNCTION GENERATE_AND_CHECK_RULESET_ID()
RETURNS TRIGGER AS $$
DECLARE RANDOM_ID INTEGER ;
BEGIN
    IF NEW.RULESET_ID IS NULL THEN NEW.RULESET_ID := (FLOOR(RANDOM() * 10000000) + 1);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
-- CREATE TRIGGER ON TABLE TO EXECUTE FUNCTION 
CREATE TRIGGER BEFORE_INSERT_TO_RULESET
BEFORE INSERT ON DEV.DQ_CTL_RULESET 
FOR EACH ROW EXECUTE FUNCTION GENERATE_AND_CHECK_RULESET_ID();


-- CREATE HISTORY TABLE WHICH STORES DATA COPY & AUDIT UUID FOR ACTION BY USER 
CREATE TABLE DEV_HISTORY.HIST_DQ_CTL_RULESET 
(
    RULESET_ID BIGINT NOT NULL PRIMARY KEY,
    RULESET_TYPE VARCHAR(15) NOT NULL,
    RULESET_DESC TEXT NOT NULL, 
    RULESET_OWNER VARCHAR(50) NOT NULL DEFAULT UPPER(CURRENT_USER),
    RULESET_DISABLED CHAR(1) NOT NULL DEFAULT 'N',
    AUDIT_ID UUID NOT NULL,
    PRIMARY KEY (RULESET_ID, AUDIT_ID)
);
-- NO INDEX NEEDED AS PK DOES BY DEFAULT, BUT BELOW IS AN EXAMPLE OF A PARTIAL INDEX
-- CREATE INDEX HST_RULESET_INDEX ON DEV_HISTORY.HIST_DQ_CTL_RULESET
-- (RULESET_ID, AUDIT_ID) WHERE RULESET_DISABLED = 'Y';

-- CREATE TRIGGER TO PREVENT UPDATE / DELETE TO HISTORY TABLE EXCEPT BY ADMIN
CREATE TRIGGER APPLY_RESTRICT_FUNC_RULESET_HST
BEFORE UPDATE OR DELETE ON DEV_HISTORY.HIST_DQ_CTL_RULESET
FOR EACH ROW EXECUTE FUNCTION RESTRICT_UPDATE_DELETE_TO_TABLE();

-- CREATE FUNCTION & TRIGGER COMBO TO AUTO COPY ACTION FROM DEV TABLE
-- TO DEV_HISTORY TABLE, WHEN IT HAPPENS 
CREATE OR REPLACE FUNCTION RULESET_COPY_TO_HST()
RETURNS TRIGGER AS $$
DECLARE AUDIT_ID_VALUE UUID ;
BEGIN
-- ACTION FOR INSERT OR UPDATE
    IF UPPER(TG_OP) IN ('INSERT', 'UPDATE') THEN
    -- INSERT RECORD TO AUDIT TABLE. ONLY REQUIRES `ACTION` KEYWORD VALUE, AS OTHER FIELDS AUTO-POP
    -- THE GENERATED AUDIT_ID VALUE WILL BE RETURNED INTO A VARIABLE TO BE USED IN OTHER TABLE INSERT
        INSERT INTO DEV_HISTORY.RULESREPO_AUDIT (USER_ACTION) VALUES (UPPER(TG_OP))
        RETURNING AUDIT_ID INTO AUDIT_ID_VALUE;
    -- NOW INSERT CORRESPONDING DATA TO DEV_HISTORY.HIST_DQ_CTL_RULESET WITH AUDIT_ID KEY 
        INSERT INTO DEV_HISTORY.HIST_DQ_CTL_RULESET
        (RULESET_ID, RULESET_TYPE, RULESET_DESC, RULESET_OWNER, RULESET_DISABLED, AUDIT_ID)
        VALUES (NEW.RULESET_ID, NEW.RULESET_TYPE, NEW.RULESET_DESC, NEW.RULESET_OWNER, 
                NEW.RULESET_DISABLED, AUDIT_ID_VALUE);
-- NOW REPEAT FOR DELETE ACTION 
    ELSEIF UPPER(TG_OP) = 'DELETE' THEN 
    -- INSERT TO AUDIT MASTER 
        INSERT INTO DEV_HISTORY.RULESREPO_AUDIT (USER_ACTION) VALUES (UPPER(TG_OP))
        RETURNING AUDIT_ID INTO AUDIT_ID_VALUE;
    -- INSERT TO HISTORY COPY 
        INSERT INTO DEV_HISTORY.HIST_DQ_CTL_RULESET
        (RULESET_ID, RULESET_TYPE, RULESET_DESC, RULESET_OWNER, RULESET_DISABLED, AUDIT_ID)
        VALUES (OLD.RULESET_ID, OLD.RULESET_TYPE, OLD.RULESET_DESC, OLD.RULESET_OWNER, 
                OLD.RULESET_DISABLED, AUDIT_ID_VALUE);
    END IF;
    -- DETERMINE WHETHER TO RETURN OLD OR NEW 
    IF UPPER(TG_OP) IN ('INSERT','UPDATE') THEN RETURN NEW;
    ELSEIF UPPER(TG_OP) IN ('DELETE') THEN RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;
-- CREATE TRIGGER TO RUN COPY FUNCTION WHEN ACTION HAPPENS TO LIVE TABLE 
CREATE TRIGGER APPLY_RULESET_COPY_TO_HST
AFTER INSERT OR UPDATE OR DELETE ON DEV.DQ_CTL_RULESET 
FOR EACH ROW EXECUTE FUNCTION RULESET_COPY_TO_HST();

-- ========================================================================================================
-- ========================================================================================================

-- CREATE AN "ADDITIONAL OWNERS" RULESET TABLE 
CREATE TABLE DEV.DQ_RULESET_OWNERS
(
    RULESET_ID BIGINT NOT NULL,
    ADDITIONAL_RULESET_OWNER VARCHAR(50) NOT NULL,
    OWNER_DISABLE CHAR(1) NOT NULL DEFAULT 'N',
    PRIMARY KEY (RULESET_ID, ADDITIONAL_RULESET_OWNER)
);
-- CONSTRAINT TO ENSURE VALUES IN THE DISABLED COLUMN 
ALTER TABLE DEV.DQ_RULESET_OWNERS ADD CONSTRAINT OWNER_DISABLE CHECK (OWNER_DISABLED IN ('Y','N'));
ALTER TABLE DEV.DQ_RULESET_OWNERS ADD CONSTRAINT ADDITIONAL_RULESET_OWNER_POPULATED
CHECK (TRIM(ADDITIONAL_RULESET_OWNER) != '');
-- ADD FOREIGN KEY AGAINST RULESET TABLE 
ALTER TABLE DEV.DQ_RULESET_OWNERS ADD CONSTRAINT RULESET_ID_CHECK
FOREIGN KEY (RULESET_ID) REFERENCES DEV.DQ_CTL_RULESET (RULESET_ID);


-- CREATE A FUNCTION TO VALIDATE A RULESET OWNER, TO ALLOW THEM TO ADD ADDITIONAL
-- OWNERS TO THEIR RULESET (AND ADD ADMIN EXCEPTION)
CREATE OR REPLACE FUNCTION VALIDATE_RULESET_OWNER()
RETURNS TRIGGER AS $$
BEGIN
    IF UPPER(TG_OP) IN ('INSERT', 'UPDATE') AND NOT EXISTS(
        SELECT 1 FROM DEV.DQ_CTL_RULESET
        WHERE RULESET_ID = NEW.RULESET_ID AND UPPER(RULESET_OWNER) = UPPER(CURRENT_USER)
    ) AND 
    UPPER(CURRENT_USER) NOT IN (
        SELECT UPPER(U.USENAME) AS USERNAME
        FROM PG_USER AS U 
        JOIN PG_GROUP AS G
        ON U.USESYSID = ANY(G.GROLIST) 
        WHERE G.GRONAME = 'ADMIN_ROLE' 
    ) -- THEN RAISE AN EXCEPTION MESSAGE 
    THEN RAISE EXCEPTION 'You have attempted to enter a record for a Ruleset ID you are not owner of';
    ELSEIF UPPER(TG_OP) IN ('DELETE') AND NOT EXISTS(
        SELECT 1 FROM DEV.DQ_CTL_RULESET
        WHERE RULESET_ID = OLD.RULESET_ID AND UPPER(RULESET_OWNER) = UPPER(CURRENT_USER)
    ) AND 
    UPPER(CURRENT_USER) NOT IN (
        SELECT UPPER(U.USENAME) AS USERNAME
        FROM PG_USER AS U 
        JOIN PG_GROUP AS G
        ON U.USESYSID = ANY(G.GROLIST) 
        WHERE G.GRONAME = 'ADMIN_ROLE' 
    ) -- THEN RAISE AN EXCEPTION MESSAGE 
    THEN RAISE EXCEPTION 'You have attempted to remove a record for a Ruleset ID you are not owner of';
    END IF;
    -- DETERMINE TO RETURN NEW OR OLD 
    IF UPPER(TG_OP) IN ('INSERT','UPDATE') THEN RETURN NEW;
    ELSEIF UPPER(TG_OP) IN ('DELETE') THEN RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- IMPLEMENT WITH TRIGGER 
CREATE TRIGGER CHECK_OWNER_BEFORE_INSERT
BEFORE INSERT OR UPDATE OR DELETE ON DEV.DQ_RULESET_OWNERS
FOR EACH ROW EXECUTE FUNCTION VALIDATE_RULESET_OWNER();


-- CREATE AN ADDITIONAL FUNCTION, WHICH CHECKS IF USER IS NOW LISTED AS ADDITIONAL OWNER
CREATE OR REPLACE FUNCTION AUTH_RULESET_OWNER()
RETURNS TRIGGER AS $$ 
BEGIN
    IF UPPER(TG_OP) IN ('INSERT', 'UPDATE') AND NOT EXISTS (
        SELECT 1 FROM DEV.DQ_CTL_RULESET 
        WHERE RULESET_ID = NEW.RULESET_ID AND UPPER(RULESET_OWNER) = UPPER(CURRENT_USER)
    ) AND 
    NOT EXISTS (
        SELECT 1 FROM DEV.DQ_RULESET_OWNERS 
        WHERE RULESET_ID = NEW.RULESET_ID AND UPPER(ADDITIONAL_RULESET_OWNER) = UPPER(CURRENT_USER) 
            AND OWNER_DISABLE = 'N' 
    ) AND
    UPPER(CURRENT_USER) NOT IN (
        SELECT UPPER(U.USENAME) AS USERNAME
        FROM PG_USER AS U 
        JOIN PG_GROUP AS G 
        ON U.USESYSID = ANY(G.GROLIST) 
        WHERE G.GRONAME = 'ADMIN_ROLE' 
    )
    THEN RAISE EXCEPTION 'You do not have permission to Insert/Modify this Ruleset ID';
    ELSEIF UPPER(TG_OP) IN ('DELETE') AND NOT EXISTS (
        SELECT 1 FROM DEV.DQ_CTL_RULESET 
        WHERE RULESET_ID = OLD.RULESET_ID AND UPPER(RULESET_OWNER) = UPPER(CURRENT_USER)
    ) AND 
    NOT EXISTS (
        SELECT 1 FROM DEV.DQ_RULESET_OWNERS 
        WHERE RULESET_ID = OLD.RULESET_ID AND UPPER(ADDITIONAL_RULESET_OWNER) = UPPER(CURRENT_USER) 
            AND OWNER_DISABLE = 'N' 
    ) AND
    UPPER(CURRENT_USER) NOT IN (
        SELECT UPPER(U.USENAME) AS USERNAME
        FROM PG_USER AS U 
        JOIN PG_GROUP AS G 
        ON U.USESYSID = ANY(G.GROLIST) 
        WHERE G.GRONAME = 'ADMIN_ROLE' 
    )
    THEN RAISE EXCEPTION 'You do not have permission to Delete this Ruleset ID';
    END IF;
    -- DETERMINE TO RETURN NEW OR OLD 
    IF UPPER(TG_OP) IN ('INSERT','UPDATE') THEN RETURN NEW;
    ELSEIF UPPER(TG_OP) IN ('DELETE') THEN RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;


-- ADD IN SOME CHECKS TO AUTHORISE RULESET OWNERS ON ABOVE TABLES
CREATE TRIGGER CHECK_OWNER_BEFORE_UPP_DEL_MASTER
BEFORE UPDATE OR DELETE ON DEV.DQ_CTL_RULESET 
FOR EACH ROW EXECUTE FUNCTION AUTH_RULESET_OWNER();

-- ========================================================================================================
-- ========================================================================================================

-- CREATE A TABLE FOR EACH RULE IN A RULESET, & IT'S LOGIC 
CREATE TABLE DEV.DQ_CTL_RULE
(
    RULESET_ID BIGINT NOT NULL,
    RULE_ID BIGINT NOT NULL,
    RULE_DESCRIPTION TEXT NOT NULL,
    RULE_LOGIC VARCHAR(50000) NOT NULL,
    RULE_DISABLED CHAR(1) NOT NULL DEFAULT 'N',
    PRIMARY KEY (RULESET_ID, RULE_ID) 
);
-- CONSTRAINTS 
ALTER TABLE DEV.DQ_CTL_RULE ADD CONSTRAINT RULE_DISABLED CHECK (RULE_DISABLED IN ('Y','N'));
ALTER TABLE DEV.DQ_CTL_RULE ADD CONSTRAINT RULE_DESC_EMPTY CHECK (TRIM(RULE_DESCRIPTION) != '');
ALTER TABLE DEV.DQ_CTL_RULE ADD CONSTRAINT UNQ_RULES UNIQUE (RULESET_ID, RULE_DESCRIPTION) ;
ALTER TABLE DEV.DQ_CTL_RULE ADD CONSTRAINT RULE_LOGIC_EMPTY CHECK (TRIM(RULE_LOGIC) != '');
ALTER TABLE DEV.DQ_CTL_RULE ADD CONSTRAINT RULESET_ID_FK 
FOREIGN KEY (RULESET_ID) REFERENCES DEV.DQ_CTL_RULESET (RULESET_ID);

-- CREATE HISTORY COPY 
CREATE TABLE DEV_HISTORY.HIST_DQ_CTL_RULE
(
    RULESET_ID BIGINT NOT NULL,
    RULE_ID BIGINT NOT NULL,
    RULE_DESCRIPTION TEXT NOT NULL,
    RULE_LOGIC VARCHAR(50000) NOT NULL,
    RULE_DISABLED CHAR(1) NOT NULL DEFAULT 'N',
    AUDIT_ID UUID NOT NULL,
    PRIMARY KEY (RULESET_ID, RULE_ID, AUDIT_ID) 
);

-- CREATE TRIGGER TO PREVENT INSERT / UPDATE / DELETE ON CTL_RULE 
-- FOR RULESET_IDs WHERE USER IS NOT LISTED AS OWNER 
CREATE TRIGGER RULE_CTL_CHECK_OWNER
BEFORE INSERT OR UPDATE OR DELETE ON DEV.DQ_CTL_RULE 
FOR EACH ROW EXECUTE FUNCTION AUTH_RULESET_OWNER();

-- CREATE TRIGGER TO PREVENT UPDATE OR DELETE ON HIST TABLE EXCEPT BY ADMIN
CREATE TRIGGER RULE_HST_UPD_DEL_RESTRICT
BEFORE UPDATE OR DELETE ON DEV_HISTORY.HIST_DQ_CTL_RULE
FOR EACH ROW EXECUTE FUNCTION RESTRICT_UPDATE_DELETE_TO_TABLE();

-- CREATE TRIGGER TO PREVENT INSERT INTO HISTORY TABLE FOR A RULESET_ID NO OWNERSHIP OF 
CREATE TRIGGER RULE_HST_CHECK_OWNER
BEFORE INSERT ON DEV_HISTORY.HIST_DQ_CTL_RULE 
FOR EACH ROW EXECUTE FUNCTION AUTH_RULESET_OWNER();

-- NOW, CREATE A FUNCTION THAT ON AN ACTION TO THE RULE TABLE, CREATES AN AUDIT RECORD
-- AND LOADS A COPY OF THE DATA TO THE HISTORY TABLE
CREATE OR REPLACE FUNCTION RULE_COPY_TO_HST()
RETURNS TRIGGER AS $$
DECLARE AUDIT_ID_VALUE UUID;
BEGIN
    IF UPPER(TG_OP) IN ('INSERT','UPDATE') THEN
        -- INSERT TO AUDIT TABLE & RETURN GENERATED UUID 
        INSERT INTO DEV_HISTORY.RULESREPO_AUDIT (USER_ACTION) VALUES (UPPER(TG_OP))
        RETURNING AUDIT_ID INTO AUDIT_ID_VALUE;
        -- NOW PERFORM COPY OF RULE TO RULE HISTORY 
        INSERT INTO DEV_HISTORY.HIST_DQ_CTL_RULE 
        (RULESET_ID, RULE_ID, RULE_DESCRIPTION, RULE_LOGIC, RULE_DISABLED, AUDIT_ID)
        VALUES 
        (NEW.RULESET_ID, NEW.RULE_ID, NEW.RULE_DESCRIPTION, NEW.RULE_LOGIC, NEW.RULE_DISABLED, AUDIT_ID_VALUE);

    ELSEIF UPPER(TG_OP) IN ('DELETE') THEN 
        -- INSERT TO AUDIT TABLE & RETURN GENERATED UUID 
        INSERT INTO DEV_HISTORY.RULESREPO_AUDIT (USER_ACTION) VALUES (UPPER(TG_OP))
        RETURNING AUDIT_ID INTO AUDIT_ID_VALUE;
        -- NOW PERFORM COPY OF RULE TO RULE HISTORY 
        INSERT INTO DEV_HISTORY.HIST_DQ_CTL_RULE 
        (RULESET_ID, RULE_ID, RULE_DESCRIPTION, RULE_LOGIC, RULE_DISABLED, AUDIT_ID)
        VALUES 
        (OLD.RULESET_ID, OLD.RULE_ID, OLD.RULE_DESCRIPTION, OLD.RULE_LOGIC, OLD.RULE_DISABLED, AUDIT_ID_VALUE);
    END IF;
    -- DETERMINE TO RETURN NEW OR OLD 
    IF UPPER(TG_OP) IN ('INSERT','UPDATE') THEN RETURN NEW;
    ESLEIF UPPER(TG_OP) IN ('DELETE') THEN RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;
-- APPLY VIA A TRIGGER ON ACTIONS TO THE DEV.DQ_CTL_RULE TABLE 
CREATE TRIGGER APPLY_RULE_COPY_TO_HST
AFTER INSERT OR UPDATE OR DELETE ON DEV.DQ_CTL_RULE
FOR EACH ROW EXECUTE FUNCTION RULE_COPY_TO_HST();


-- END 