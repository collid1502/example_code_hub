-- using a window function to identify a lag / lead event 
-- in this example, it can be used to identify a capital repayment holiday on a loan,
-- by searching for "LIMIT_REDUCE_DATE" aka when the loan balance should next come down 
-- and if these dates extend out 

SELECT 
    A.*,
    LAG(REPAYMENT_GAP_IN_MONTHS, 1) OVER 
    (PARTITION BY ACCNUM, SORTCODE ORDER BY ACCNUM, SORTCODE, BUSINESS_DATE) AS PREV_REPAYMENT_GAP_IN_MONTHS

FROM 
(
    SELECT 
        ACCNUM, 
        SORTCODE, 
        BUSINESS_DATE,
        TO_DATE(FROM_UNIXTIME(UNIX_TIMESTAMP(CAST(LIMIT_REDUCE_DATE AS STRING), "yyyyMMdd"))) 
            AS NEXT_LIMIT_REDUCE_DATE,

        TO_DATE(FROM_UNIXTIME(UNIX_TIMESTAMP(CAST(LAG(LIMIT_REDUCE_DATE, 1) OVER
        (PARTITION BY ACCNUM, SORTCODE ORDER BY ACCNUM, SORTCODE, BUSINESS_DATE) AS STRING), "yyyyMMdd")))) 
            AS PREV_NEXT_LIMIT_REDUCE_DATE,

        INT_MONTHS_BETWEEN(
            TO_DATE(FROM_UNIXTIME(UNIX_TIMESTAMP(CAST(LIMIT_REDUCE_DATE AS STRING), "yyyyMMdd"))),
            TO_DATE(FROM_UNIXTIME(UNIX_TIMESTAMP(CAST(LAG(LIMIT_REDUCE_DATE, 1) OVER 
            (PARTITION BY ACCNUM, SORTCODE ORDER BY ACCNUM, SORTCODE, BUSINESS_DATE) AS STRING), "yyyyMMdd")))
            ) AS REPAYMENT_GAP_IN_MONTHS 
    
    FROM 
        SCHEMA.CUSTOMER_LOANS 
    WHERE BUSINESS_DATE BETWEEN '2022-01-01' AND '2022-06-30' 
) AS A 
WHERE 
    A.NEXT_LIMIT_REDUCE_DATE <> A.PREV_NEXT_LIMIT_REDUCE_DATE
AND A.REPAYMENT_GAP_IN_MONTHS > 0

ORDER BY A.ACCNUM, A.SORTCODE, A.BUSINESS_DATE 
;
